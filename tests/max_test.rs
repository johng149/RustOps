use RustOps::functions::max;
use ndarray::ArrayD;
use ndarray_npy::read_npy;

// filepath: /media/john/Tertiary/Projects/ML/RustOps/tests/max_test.rs

const INPUT_FILENAME: &str = "max_max_x.npy";
const OUTPUT_V_PREFIX: &str = "max_max_v_dim";
const OUTPUT_I_PREFIX: &str = "max_max_i_dim";
const NPY_SUFFIX: &str = ".npy";

/// Tests the max function implementation by comparing against reference outputs.
/// The test loads input data and expected outputs from NPY files generated by the Python reference.
#[test]
fn test_max_ndarray() {
    // Load the input tensor
    let xfile = format!("data/{}", INPUT_FILENAME);
    let x: ArrayD<f32> = read_npy(&xfile).unwrap();

    // Get the number of dimensions from the input shape
    let ndim = x.ndim();

    // Test max along each dimension
    for dim in 0..ndim {
        // Define file paths for expected values and indices
        let vfile = format!("data/{}{}{}", OUTPUT_V_PREFIX, dim, NPY_SUFFIX);
        let ifile = format!("data/{}{}{}", OUTPUT_I_PREFIX, dim, NPY_SUFFIX);

        // Load expected max values and indices
        let expected_values: ArrayD<f32> = read_npy(&vfile).unwrap();
        let expected_indices: ArrayD<i64> = read_npy(&ifile).unwrap();

        println!("Testing max along dimension {}", dim);

        // Call our max implementation
        let (max_values, max_indices) = max::max(&x, dim).unwrap();

        // Convert to ArrayD for comparison (if max returns a different array type)
        let max_values_arrayd: ArrayD<f32> = max_values.into_dyn();
        let max_indices_arrayd: ArrayD<i64> = max_indices.into_dyn();

        // Assert that our results match the expected outputs
        assert_eq!(max_values_arrayd, expected_values);
        assert_eq!(max_indices_arrayd, expected_indices);
    }
}
